[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Soccer Stats",
    "section": "",
    "text": "1 Introduction\nSoccer is the most popular sport globally, with over 2 billion viewers tuning in to the FIFA World Cup Final 2022. Recently, the game has been transformed by the integration of data analytics, reshaping how teams approach strategy. Soccer managers now rely heavily on data analysis to make critical decisions, such as selecting the starting lineup, identifying transfer market targets, and determining in-game substitutions. Additionally, extensive datasets of soccer matches are readily available, enabling deeper insights into the sport.\nThis project aims to conduct an in-depth analysis of soccer performance, focusing on key factors and questions that impact outcomes at both the player and team levels. The primary goal is to extract actionable insights by exploring various dynamics within the data.\nOur analysis will examine player performance across consecutive matches, evaluating how individuals sustain or adapt their performance over time while identifying patterns of consistency or decline. Beyond individual performance, we will assess overall team performance, comparing actual outcomes with expected performance to pinpoint teams that are overachieving or underperforming.\nKey elements of the study include analyzing how passing accuracy and assist patterns influence team success, investigating the advantages of playing at home, and assessing the impact of starting lineups and in-game substitutions on match results. The findings will be presented through detailed charts and metrics, offering a clear framework for building the ultimate team.\nBy utilizing data-driven techniques, this project seeks to deliver valuable insights that can help teams optimize their strategies and give fans a deeper understanding of the elements driving success on the soccer field.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "2  Data",
    "section": "",
    "text": "2.1 Description\nOur dataset consists of 23 columns, with the number of rows/samples depending on the specific range of match_ids included. For example, in the dataset below, we used match_ids ranging from 1 to 500. It is important to note that match_ids from indexes 1 until 80 are absent. Instead of generating an error when a match_id is missing, we implemented a tryCatch function to handle this scenario gracefully. This function checks if a match_id exists, and if it does not, it inserts a NaN value in the dataset. As a result, any NaN values in our dataset are solely due to missing match_ids; otherwise, the dataset is free of missing values or NaNs. In the case of match_ids 1 to 500, our dataset has a total of 11,654 observations, resulting in a dataset shape of 11,654 rows by 23 columns.\nThe dataset includes the following features along with their descriptions:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#description",
    "href": "data.html#description",
    "title": "2  Data",
    "section": "",
    "text": "•   match_id: The unique identifier for each match. If a match is not present in the dataset, this value is NaN.\n•   id: A unique identifier for each row in the dataset.\n•   team_id: The unique identifier for each team. For example, Manchester United has a team_id of 89.\n•   home_away: Indicates whether the player participated in a home or away game. h stands for a home stadium, and a stands for an away stadium.\n•   player_id: A unique identifier for each player. For instance, Sergio Romero has a player_id of 560.\n•   swap_id: An identifier related to player swaps .\n•   player: The name of the player the row data refers to.\n•   position: The position the player played in during the match (e.g., GK for Goalkeeper).\n•   positionOrder: A ranking or order related to player positions (specific details are not provided).\n•   time_played: The total minutes a player participated in the match.\n•   goals: The number of goals scored by the player during the match.\n•   own_goals: The number of own goals scored by the player in the match.\n•   shots: The number of shots taken by the player during the match.\n•   xG: Expected Goals, an estimate of the goals the player was predicted to score based on shot quality and other factors.\n•   yellow_card: The number of yellow cards received by the player during the match.\n•   red_card: Indicates if the player received a red card (a player can only receive a maximum of one red card per match).\n•   roaster_in: Whether the player was substituted into the game .\n•   roaster_out: Whether the player was substituted out of the game .\n•   key_passes: The number of key passes made by the player, which are passes that lead to a scoring opportunity.\n•   assists: The total assists made by the player during the match.\n•   xA: Expected Assists, predicting how many assists the player should have contributed in the match.\n•   xGChain: A metric indicating the cumulative expected goals involvement in possessions the player is part of.\n•   xGBuildup: Expected goals involvement in build-up play, excluding key passes and shots.\n\n\n2.1.1 Dataset Source\nDataset R Package\nDataset Repo (Source)\n\n\n2.1.2 Fetching Data (for specific match_ids)\nThis dataset provides a comprehensive view of player performance and match dynamics using both traditional and advanced metrics.\n\n\nCode\n#install.packages('devtools')\n#devtools::install_github(\"JaseZiv/worldfootballR\")\n\n\n\n\nCode\n# devtools::install_github(\"ewenme/understatr\")\nlibrary(understatr)\n\n\nThe data was collected by comparing multiple datasets from different sources related to soccer and assessing their usability and relevance. We finalized on World Football Data for R. The research and comparison of the datasets were done collectively by all three members of the group.\nThe website guiding the installation of the dataset and providing the link to the GitHub repository was last updated on November 15, 2024, with a prior update in June 2024. The most recent change to the repository, specifically to the README file, was made 4 days ago. The author appears to update the repository frequently, as indicated by the varying timestamps on different folders and files.\nThe World Football Data repository offers a wide range of datasets, and for this project, we have chosen to work with the player performance data for individual matches. This dataset was last updated 4 months ago. We plan to update the match_ids to a sequential list of match_id values and fetch data for those match_ids. If no data is available for a particular match_id, we will add a row with NaN values. Otherwise, we will add the corresponding match data.\nOne issue we observed is that some of the data in the repository has not been updated recently, with some datasets being as old as 2 years. This is another reason we chose to work with player performance in specific matches, as this data is more recently updated.\nTo fetch data for a single match, we can use the understat_match_players function from the understatr library. Below is a glimpse of how we can fetch data for match ID 14788.\n\n\nCode\nlibrary(worldfootballR)\nwba_liv_players &lt;- understat_match_players(match_url = \"https://understat.com/match/14788\")\n\n\nCombining data for matches with the given match ID:\n\n\nCode\nlibrary(dplyr)\n\n# Define the match IDs\nmatch_ids &lt;- seq(1, 500)            #Specify the match Ids for which you want to fetch data\nmatch_list &lt;- list()\n\n# Get column names\nexample_match_url &lt;- \"https://understat.com/match/14788\"\nexample_data &lt;- tryCatch({\n  understat_match_players(match_url = example_match_url)\n}, error = function(e) {\n  data.frame() # Return an empty data frame if the example fails\n})\ndefault_columns &lt;- names(example_data)\n\n# Iterate over match IDs\nfor (id in match_ids) {\n  match_url &lt;- paste0(\"https://understat.com/match/\", id)\n  match_data &lt;- tryCatch({\n    # Attempt to fetch match data\n    understat_match_players(match_url = match_url)\n  }, error = function(e) {\n    # Handle errors by creating an NA data frame\n    data.frame(matrix(NA, nrow = 1, ncol = length(default_columns)),\n               stringsAsFactors = FALSE) %&gt;%\n      setNames(default_columns)\n  })\n\n  # Add match ID to the data\n  match_data$id &lt;- id\n  match_list[[as.character(id)]] &lt;- match_data\n}\n\n#Combine all match data into a single data frame\nall_match_players &lt;- bind_rows(match_list)\n\n\n“Creating a CSV file of the data:\n\n\nCode\n# write.csv(all_match_players, \"combined_match_players_0-500.csv\", row.names = FALSE)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#missing-value-analysis",
    "href": "data.html#missing-value-analysis",
    "title": "2  Data",
    "section": "2.2 Missing Value Analysis",
    "text": "2.2 Missing Value Analysis\nIn our dataset, missing values are introduced only for incorrect match_id values. For the correct match_id values, there are no missing values, ensuring data completeness. However, when an incorrect match_id is encountered, we add a row with NaN values for all columns except for the id column, which serves as an identifier. This approach allows us to clearly identify and track the rows with invalid match_id values. In total, there are 80 incorrect match_id values in the dataset, resulting in 80 rows where all values are NaN, except for the id.\n\n\nCode\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(VIM)\nlibrary(naniar)\nlibrary(scales)\n\nnan_summary &lt;- all_match_players %&gt;%\n  summarise(\n    all_nan_count = sum(apply(all_match_players[, -which(names(all_match_players) == \"id\")], 1, function(x) all(is.na(x)))),\n    complete_count = n() - all_nan_count\n  ) %&gt;%\n  pivot_longer(cols = c(\"all_nan_count\", \"complete_count\"), names_to = \"status\", values_to = \"count\") %&gt;%\n  mutate(\n    status = ifelse(status == \"all_nan_count\", \"All Columns NaN (except id)\", \"Complete Rows\"),\n    percentage = count / sum(count)  # Calculate percentage\n  )\n\n# Pie chart with labels (2 decimal points)\nggplot(data = nan_summary, aes(x = \"\", y = count, fill = status)) +\n  geom_bar(stat = \"identity\", width = 1) +\n  coord_polar(theta = \"y\") +\n  labs(title = \"Proportion of Rows with All Columns NaN (except id) vs. Complete Rows\") +\n  theme_void() +\n  scale_fill_manual(values = c(\"steelblue\", \"coral\")) +\n  theme(legend.title = element_blank()) +\n  geom_text(aes(label = paste0(count, \" (\", scales::percent(percentage, accuracy = 0.01), \")\")), \n            position = position_stack(vjust = 0.5))\n\n\n\n\n\n\n\n\n\nThe pie chart depicts that 99% of pur data is complete with no missing values.\n\n\nCode\n# library(ggplot2)\n# library(tidyr)\n# library(dplyr)\nlibrary(redav)\ndata_missing &lt;- all_match_players[!complete.cases(all_match_players), ]\nplot_missing(data_missing, max_cols = 8, num_char = 3, percent = FALSE) +\n  labs(title = \"Missing Values Pattern Analysis\") +\n  theme(plot.title = element_text(hjust = 2, vjust = 33.5))\n\n\n\n\n\n\n\n\n\nThe plot of missing also verifies the same information that the quality of data is very good with minimal missing values. Match IDs from 1 - 80 do not have any data and this is represented by the first bar chart. But the remaining two graphs supports our missing data analysis claim of having minimal missing values.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data</span>"
    ]
  }
]